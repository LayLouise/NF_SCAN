# -*- coding: utf-8 -*-
"""CÃ³pia de Projeto_NFSCAN

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16bFVhs7fb5sbOQKfR1AC5fBJF-O3tx7X
"""

from google.colab import drive
drive.mount('/content/drive')

!sudo apt install tesseract-ocr-por
!pip install pytesseract

import numpy as np
import cv2
import re
from matplotlib import pyplot as plt

import pytesseract
import numpy as np
import cv2
from google.colab.patches import cv2_imshow

from PIL import Image
import PIL.Image

from pytesseract import image_to_string 
import pytesseract

from pytesseract import Output

image=cv2.imread('/content/drive/MyDrive/NF_Test/02.12.21_page-0001.jpg')

# ## **Use Gaussian Blurring combined with Adaptive Threshold**
def blur_and_threshold(gray):
    gray = cv2.GaussianBlur(gray,(3,3),2)
    threshold = cv2.adaptiveThreshold(gray,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY,11,2)
    threshold = cv2.fastNlMeansDenoising(threshold, 11, 31, 9)
    return threshold
# ## **Find the Biggest Contour** 

# **Note: We made sure the minimum contour is bigger than 1/10 size of the whole picture. This helps in removing very small contours (noise) from our dataset**
def biggest_contour(contours,min_area):
    biggest = None
    max_area = 0
    biggest_n=0
    approx_contour=None
    for n,i in enumerate(contours):
            area = cv2.contourArea(i)
            if area > min_area/20:
                    peri = cv2.arcLength(i,True)
                    approx = cv2.approxPolyDP(i,0.05*peri,True)
                    if area > max_area and len(approx)==4:
                            biggest = approx
                            max_area = area
                            biggest_n=n
                            approx_contour=approx
    return biggest_n,approx_contour

def order_points(pts):
   
    pts=pts.reshape(4,2)
    rect = np.zeros((4, 2), dtype = "uint8")

    s = pts.sum(axis = 1)
    rect[0] = pts[np.argmin(s)]
    rect[2] = pts[np.argmax(s)]


    diff = np.diff(pts, axis = 1)
    rect[1] = pts[np.argmin(diff)]
    rect[3] = pts[np.argmax(diff)]

    
    return rect

def four_point_transform(image, pts):
    
    rect = order_points(pts)
    (tl, tr, br, bl) = rect

    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    maxWidth = max(int(widthA), int(widthB))
   

   
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))

  
    dst = np.array([
        [0, 0],
        [maxWidth - 1, 0],
        [maxWidth - 1, maxHeight - 1],
        [0, maxHeight - 1]], dtype = "uint8")

  
    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(image, M, (maxWidth, maxHeight))

    
    return warped

def transformation(image):
  image=image.copy()  
  height, width, channels = image.shape
  gray=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
  image_size=gray.size
  
  threshold=blur_and_threshold(gray)
 
  edges = cv2.Canny(threshold,50,150,apertureSize = 7)
  contours, hierarchy = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  simplified_contours = []


  for cnt in contours:
      hull = cv2.convexHull(cnt)
      simplified_contours.append(cv2.approxPolyDP(hull,
                                0.001*cv2.arcLength(hull,True),True))
  simplified_contours = np.array(simplified_contours)
  biggest_n,approx_contour = biggest_contour(simplified_contours,image_size)

  threshold = cv2.drawContours(image, simplified_contours ,biggest_n, (0,255,0), 1)

  dst = 0
  
  if approx_contour is not None and len(approx_contour)==4:
      approx_contour=np.float32(approx_contour)
      dst=four_point_transform(threshold,approx_contour)
  croppedImage = dst
  
  return croppedImage



custom_config = r'--oem 3 --psm 11'
details = pytesseract.image_to_data(image, output_type=Output.DICT, config=custom_config, lang='por')
print(details.keys())

total_boxes=len(details['text'])
for sequence_number in range(total_boxes):
  if int(details['conf'][sequence_number])> 40:
    
    (x, y, w, h)= (details['left'][sequence_number], details['top'][sequence_number], details['width'][sequence_number], details['height'][sequence_number])
    
    threshold_img=cv2.rectangle(image,(x, y), (x + w, h + y), (0,255,0), 1)
    
    cv2_imshow(threshold_img)
    

parse_text = []

word_list = []

last_word = 'LOCALIDADE:'

for word in details['text']:

  if word!='':

    word_list.append(word)

    last_word = word

  if (last_word!='' and word == '') or (word==details['text'][-1]):

    parse_text.append(word_list)

    word_list = []

import csv
with open('result_text03.txt',  'w', newline="") as file:
  csv.writer(file, delimiter=" ").writerows(parse_text)

!pip install pandas

import pandas as pd

data = pd.DataFrame(list(), columns=['Review'])
data

def clean(text):
    return re.sub('[^A-Za-z0-9" "]+', ' ', text)
data['Cleaned Review'] = data['Review'].apply(clean)
data

for column in data[['Cleaned Review']]:
    columnSeriesObj = data[column]
    all_rev = columnSeriesObj.values

import csv

with open('/content/result_text03.txt', 'r') as in_file:
    stripped = (line.strip() for line in in_file)
    lines = (line.split(",") for line in stripped if line)
   
with open('test_01.csv', 'w') as out_file:
        writer = csv.writer(out_file)
        writer.writerow(('title', 'intro'))
        writer.writerows(lines)